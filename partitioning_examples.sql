-- ============================================================
-- partitioning_examples.sql
-- Reference DDL for time-range partitioning in PostgreSQL 15
-- Targets: meter_readings (by reading_at) and maintenance_logs (by performed_at)
-- Safe-mode: transaction ends with ROLLBACK (change to COMMIT to apply).
-- Review and adapt to your environment before running in production.
-- ============================================================

\set ON_ERROR_STOP 1
BEGIN;

----------------------------------------------------------------
-- A) meter_readings → partitioned by reading_at (RANGE)
----------------------------------------------------------------

-- 1) Create partitioned parent (columns copied from schema; PK includes partition key)
CREATE TABLE IF NOT EXISTS meter_readings_p (
  id               BIGINT GENERATED BY DEFAULT AS IDENTITY,
  meter_id         BIGINT NOT NULL,
  reading_value    NUMERIC NOT NULL CHECK (reading_value >= 0),
  reading_at       TIMESTAMPTZ(0) NOT NULL,
  source           TEXT,
  meta             JSONB,
  created_at       TIMESTAMPTZ(0) NOT NULL DEFAULT date_trunc('second', now()),
  created_by       UUID,
  updated_at       TIMESTAMPTZ(0),
  updated_by       UUID,
  CONSTRAINT meter_readings_p_pk PRIMARY KEY (id, reading_at),
  CONSTRAINT meter_readings_p_meter_fk FOREIGN KEY (meter_id) REFERENCES equipment_meters(id) ON DELETE RESTRICT
) PARTITION BY RANGE (reading_at);

-- 2) Constraints and indexes (partitioned)
-- Unique per meter + timestamp (includes partition key → allowed)
CREATE UNIQUE INDEX IF NOT EXISTS meter_readings_p_uq_meter_at ON meter_readings_p (meter_id, reading_at);
-- Common access paths
CREATE INDEX IF NOT EXISTS meter_readings_p_idx_meter_at ON meter_readings_p (meter_id, reading_at);
CREATE INDEX IF NOT EXISTS meter_readings_p_idx_at       ON meter_readings_p (reading_at);

-- 3) Create yearly partitions for current_year-1 .. current_year+1
DO $$
DECLARE
  y INT := EXTRACT(YEAR FROM now())::INT;
BEGIN
  FOR i IN y-1..y+1 LOOP
    EXECUTE format(
      'CREATE TABLE IF NOT EXISTS meter_readings_%s PARTITION OF meter_readings_p FOR VALUES FROM (%L) TO (%L);',
      i, (i || '-01-01'), ((i+1) || '-01-01')
    );
  END LOOP;
END$$;

-- 4) Copy data from the original table (if exists)
--    Note: the parent is partitioned; rows route to the right child.
DO $$
BEGIN
  IF to_regclass('public.meter_readings') IS NOT NULL THEN
    EXECUTE
      'INSERT INTO meter_readings_p (id, meter_id, reading_value, reading_at, source, meta, created_at, created_by, updated_at, updated_by)
       SELECT id, meter_id, reading_value, reading_at, source, meta, created_at, created_by, updated_at, updated_by
       FROM meter_readings';
  END IF;
END$$;

-- 5) Swap: rename old → _old; parent → live name
DO $$
BEGIN
  IF to_regclass('public.meter_readings') IS NOT NULL THEN
    EXECUTE 'ALTER TABLE meter_readings RENAME TO meter_readings_old';
  END IF;
  -- rename parent to the canonical name
  EXECUTE 'ALTER TABLE meter_readings_p RENAME TO meter_readings';
END$$;

-- 6) Reset identity sequence to max(id)
DO $$
DECLARE
  seq TEXT;
  max_id BIGINT;
BEGIN
  SELECT pg_get_serial_sequence('meter_readings','id') INTO seq;
  IF seq IS NOT NULL THEN
    EXECUTE 'SELECT COALESCE(MAX(id),0) FROM meter_readings' INTO max_id;
    EXECUTE format('SELECT setval(%L, %s, %s)', seq, max_id, CASE WHEN max_id = 0 THEN 'false' ELSE 'true' END);
  END IF;
END$$;

-- (Optional) Drop old table after validation
-- DROP TABLE IF EXISTS meter_readings_old;


----------------------------------------------------------------
-- B) maintenance_logs → partitioned by performed_at (RANGE)
----------------------------------------------------------------

-- 1) Create partitioned parent (columns copied from schema; PK includes partition key)
CREATE TABLE IF NOT EXISTS maintenance_logs_p (
  id                       BIGINT GENERATED BY DEFAULT AS IDENTITY,
  equipment_id             BIGINT NOT NULL,
  equipment_component_id   BIGINT,
  task_id                  BIGINT NOT NULL,
  plan_id                  BIGINT,
  performed_at             TIMESTAMPTZ(0) NOT NULL DEFAULT date_trunc('second', now()),
  usage_counter_id         BIGINT,
  usage_value_at_service   NUMERIC(18,3),
  performed_by             TEXT,
  notes                    TEXT,
  parts_used               JSONB,
  created_at               TIMESTAMPTZ(0) NOT NULL DEFAULT date_trunc('second', now()),
  created_by               UUID,
  updated_at               TIMESTAMPTZ(0),
  updated_by               UUID,
  -- Checks from schema
  CONSTRAINT maintenance_logs_p_chk_usage_nonneg CHECK (usage_value_at_service IS NULL OR usage_value_at_service >= 0),
  CONSTRAINT maintenance_logs_p_chk_usage_has_counter CHECK (usage_value_at_service IS NULL OR usage_counter_id IS NOT NULL),
  -- FKs
  CONSTRAINT maintenance_logs_p_equipment_fk           FOREIGN KEY (equipment_id)           REFERENCES equipment(id) ON DELETE RESTRICT,
  CONSTRAINT maintenance_logs_p_component_fk           FOREIGN KEY (equipment_component_id) REFERENCES equipment_components(id) ON DELETE RESTRICT,
  CONSTRAINT maintenance_logs_p_task_fk                FOREIGN KEY (task_id)                REFERENCES maintenance_tasks(id) ON DELETE RESTRICT,
  CONSTRAINT maintenance_logs_p_plan_fk                FOREIGN KEY (plan_id)                REFERENCES maintenance_plans(id) ON DELETE SET NULL,
  CONSTRAINT maintenance_logs_p_usage_counter_fk       FOREIGN KEY (usage_counter_id)       REFERENCES counter_types(id) ON DELETE RESTRICT,
  -- Composite PK must include partition key
  CONSTRAINT maintenance_logs_p_pk PRIMARY KEY (id, performed_at)
) PARTITION BY RANGE (performed_at);

-- 2) Partitioned indexes (inherit to children)
CREATE INDEX IF NOT EXISTS maintenance_logs_p_idx_equipment_time   ON maintenance_logs_p (equipment_id, performed_at);
CREATE INDEX IF NOT EXISTS maintenance_logs_p_idx_task_time        ON maintenance_logs_p (task_id, performed_at);
CREATE INDEX IF NOT EXISTS maintenance_logs_p_idx_component_time   ON maintenance_logs_p (equipment_component_id, performed_at);
CREATE INDEX IF NOT EXISTS maintenance_logs_p_idx_plan             ON maintenance_logs_p (plan_id);
CREATE INDEX IF NOT EXISTS maintenance_logs_p_idx_usage_counter    ON maintenance_logs_p (usage_counter_id);

-- 3) Create yearly partitions for current_year-1 .. current_year+1
DO $$
DECLARE
  y INT := EXTRACT(YEAR FROM now())::INT;
BEGIN
  FOR i IN y-1..y+1 LOOP
    EXECUTE format(
      'CREATE TABLE IF NOT EXISTS maintenance_logs_%s PARTITION OF maintenance_logs_p FOR VALUES FROM (%L) TO (%L);',
      i, (i || '-01-01'), ((i+1) || '-01-01')
    );
  END LOOP;
END$$;

-- 4) Copy data from the original table (if exists)
DO $$
BEGIN
  IF to_regclass('public.maintenance_logs') IS NOT NULL THEN
    EXECUTE
      'INSERT INTO maintenance_logs_p (id, equipment_id, equipment_component_id, task_id, plan_id, performed_at,
                                       usage_counter_id, usage_value_at_service, performed_by, notes, parts_used,
                                       created_at, created_by, updated_at, updated_by)
       SELECT id, equipment_id, equipment_component_id, task_id, plan_id, performed_at,
              usage_counter_id, usage_value_at_service, performed_by, notes, parts_used,
              created_at, created_by, updated_at, updated_by
       FROM maintenance_logs';
  END IF;
END$$;

-- 5) Swap: rename old → _old; parent → live name
DO $$
BEGIN
  IF to_regclass('public.maintenance_logs') IS NOT NULL THEN
    EXECUTE 'ALTER TABLE maintenance_logs RENAME TO maintenance_logs_old';
  END IF;
  EXECUTE 'ALTER TABLE maintenance_logs_p RENAME TO maintenance_logs';
END$$;

-- 6) Reset identity sequence to max(id)
DO $$
DECLARE
  seq TEXT;
  max_id BIGINT;
BEGIN
  SELECT pg_get_serial_sequence('maintenance_logs','id') INTO seq;
  IF seq IS NOT NULL THEN
    EXECUTE 'SELECT COALESCE(MAX(id),0) FROM maintenance_logs' INTO max_id;
    EXECUTE format('SELECT setval(%L, %s, %s)', seq, max_id, CASE WHEN max_id = 0 THEN 'false' ELSE 'true' END);
  END IF;
END$$;

-- (Optional) Drop old table after validation
-- DROP TABLE IF EXISTS maintenance_logs_old;

----------------------------------------------------------------
-- End (safe-mode)
----------------------------------------------------------------

-- Review the output, then change to COMMIT to apply.
ROLLBACK;
-- COMMIT;
